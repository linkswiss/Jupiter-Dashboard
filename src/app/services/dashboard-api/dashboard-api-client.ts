import { ApiClientBase, ApiConfig } from './dashboard-api-client-base';
/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.5.0 (NJsonSchema v10.0.27.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class SabreClient extends ApiClientBase {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(configuration: ApiConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    super(configuration);
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  /**
   * Get All Sabre Sessions from Pool
   */
  getAllSessions(): Promise<SabreGdsSessionCustomData[]> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Sabre/get-all-sessions";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGetAllSessions(_response);
    });
  }

  protected processGetAllSessions(response: Response): Promise<SabreGdsSessionCustomData[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(SabreGdsSessionCustomData.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SabreGdsSessionCustomData[]>(<any>null);
  }

  /**
   * Close and Delete a Sabre Session from Pool
   */
  deleteSession(id: string | null): Promise<SabreGdsSessionCustomData[]> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Sabre/delete-session/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processDeleteSession(_response);
    });
  }

  protected processDeleteSession(response: Response): Promise<SabreGdsSessionCustomData[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(SabreGdsSessionCustomData.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SabreGdsSessionCustomData[]>(<any>null);
  }

  /**
   * Refresh the Sabre Sessions Pool
   */
  refreshSessionPool(): Promise<SabreGdsSessionCustomData[]> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Sabre/refresh-session-pool";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processRefreshSessionPool(_response);
    });
  }

  protected processRefreshSessionPool(response: Response): Promise<SabreGdsSessionCustomData[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(SabreGdsSessionCustomData.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SabreGdsSessionCustomData[]>(<any>null);
  }
}

export class SampleRequestClient extends ApiClientBase {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(configuration: ApiConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    super(configuration);
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  saveSampleRequest(sampleRequest: SampleRequest): Promise<SampleRequest> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/SampleRequest/save-sample-request";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(sampleRequest);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processSaveSampleRequest(_response);
    });
  }

  protected processSaveSampleRequest(response: Response): Promise<SampleRequest> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SampleRequest.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SampleRequest>(<any>null);
  }

  deleteSampleRequest(sampleRequest: SampleRequest): Promise<SampleRequest> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/SampleRequest/delete-sample-request";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(sampleRequest);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processDeleteSampleRequest(_response);
    });
  }

  protected processDeleteSampleRequest(response: Response): Promise<SampleRequest> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SampleRequest.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SampleRequest>(<any>null);
  }

  getSampleRequests(requestType: string | null): Promise<SampleRequest[]> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/SampleRequest/get-sample-requests/{requestType}";
    if (requestType === undefined || requestType === null)
      throw new Error("The parameter 'requestType' must be defined.");
    url_ = url_.replace("{requestType}", encodeURIComponent("" + requestType));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGetSampleRequests(_response);
    });
  }

  protected processGetSampleRequests(response: Response): Promise<SampleRequest[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(SampleRequest.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SampleRequest[]>(<any>null);
  }

  generateSampleRequest(requestType: string | null): Promise<SampleRequest> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/SampleRequest/generate-sample-request/{requestType}";
    if (requestType === undefined || requestType === null)
      throw new Error("The parameter 'requestType' must be defined.");
    url_ = url_.replace("{requestType}", encodeURIComponent("" + requestType));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGenerateSampleRequest(_response);
    });
  }

  protected processGenerateSampleRequest(response: Response): Promise<SampleRequest> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = SampleRequest.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SampleRequest>(<any>null);
  }

  getAllSampleRequests(): Promise<SampleRequest[]> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/SampleRequest/get-all-sample-requests";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGetAllSampleRequests(_response);
    });
  }

  protected processGetAllSampleRequests(response: Response): Promise<SampleRequest[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(SampleRequest.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SampleRequest[]>(<any>null);
  }
}

export class UsersClient extends ApiClientBase {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(configuration: ApiConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    super(configuration);
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  authenticate(userParam: UserAuthRQ): Promise<User> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Users/authenticate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(userParam);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processAuthenticate(_response);
    });
  }

  protected processAuthenticate(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  logout(): Promise<FileResponse> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Users/logout";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/octet-stream"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processLogout(_response);
    });
  }

  protected processLogout(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse>(<any>null);
  }

  refreshToken(request: User): Promise<User> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Users/refresh-token";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_ = <RequestInit>{
      body: content_,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processRefreshToken(_response);
    });
  }

  protected processRefreshToken(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  createJupiterApiToken(userId: number): Promise<User> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Users/create-jupiter-api-token/{userId}";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processCreateJupiterApiToken(_response);
    });
  }

  protected processCreateJupiterApiToken(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  deleteJupiterApiToken(userId: number): Promise<User> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Users/delete-jupiter-api-token/{userId}";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processDeleteJupiterApiToken(_response);
    });
  }

  protected processDeleteJupiterApiToken(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  getUser(userId: number): Promise<User> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Users/get/{userId}";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGetUser(_response);
    });
  }

  protected processGetUser(response: Response): Promise<User> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = User.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<User>(<any>null);
  }

  getAllUsers(): Promise<User[]> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Users/get-all-users";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGetAllUsers(_response);
    });
  }

  protected processGetAllUsers(response: Response): Promise<User[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(User.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<User[]>(<any>null);
  }
}

export class UtilityClient extends ApiClientBase {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(configuration: ApiConfig, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    super(configuration);
    this.http = http ? http : <any>window;
    this.baseUrl = baseUrl ? baseUrl : "https://localhost:5001";
  }

  /**
   * Get the current AppSettings
   */
  getJupiterApiSettings(): Promise<AppSettings> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Utility/jupiter-settings";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGetJupiterApiSettings(_response);
    });
  }

  protected processGetJupiterApiSettings(response: Response): Promise<AppSettings> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AppSettings.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<AppSettings>(<any>null);
  }

  /**
   * Get all the published routes and the authorization related
   */
  getRoutes(): Promise<PublishedRoute[]> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Utility/published-routes";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGetRoutes(_response);
    });
  }

  protected processGetRoutes(response: Response): Promise<PublishedRoute[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(PublishedRoute.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<PublishedRoute[]>(<any>null);
  }

  /**
   * Get all the JUPITER API published routes and the authorization related
   */
  getJupiterRoutes(): Promise<PublishedRoute[]> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Utility/jupiter-api-routes";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGetJupiterRoutes(_response);
    });
  }

  protected processGetJupiterRoutes(response: Response): Promise<PublishedRoute[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(PublishedRoute.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<PublishedRoute[]>(<any>null);
  }

  /**
   * Get all the Cache Service Entries
   */
  getCacheEntries(): Promise<CacheEntry[]> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Utility/cache-entries";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGetCacheEntries(_response);
    });
  }

  protected processGetCacheEntries(response: Response): Promise<CacheEntry[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(CacheEntry.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CacheEntry[]>(<any>null);
  }

  /**
   * Clear the Cache Service and get all the Cache Entries -&gt; that should be empty
   */
  clearCache(): Promise<CacheEntry[]> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Utility/clear-cache";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processClearCache(_response);
    });
  }

  protected processClearCache(response: Response): Promise<CacheEntry[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(CacheEntry.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CacheEntry[]>(<any>null);
  }

  /**
   * Clear a single Cache Item on the Cache Service and get all the Cache Entries
   */
  clearSingleCacheItem(cacheKey: string | null): Promise<CacheEntry[]> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Utility/clear-cache-item/{cacheKey}";
    if (cacheKey === undefined || cacheKey === null)
      throw new Error("The parameter 'cacheKey' must be defined.");
    url_ = url_.replace("{cacheKey}", encodeURIComponent("" + cacheKey));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processClearSingleCacheItem(_response);
    });
  }

  protected processClearSingleCacheItem(response: Response): Promise<CacheEntry[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(CacheEntry.fromJS(item));
        }
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CacheEntry[]>(<any>null);
  }

  generateDashboardTypescriptClient(): Promise<FileResponse> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Utility/dashboard-typescript-client";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/octet-stream"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGenerateDashboardTypescriptClient(_response);
    });
  }

  protected processGenerateDashboardTypescriptClient(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse>(<any>null);
  }

  getErrorLogs(): Promise<AppSettings> {
    let url_ = this.baseUrl + "/jupiter-dashboard-api/1-dashboard/Utility/get-error-logs";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <RequestInit>{
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    };

    return this.transformOptions(options_).then(transformedOptions_ => {
      return this.http.fetch(url_, transformedOptions_);
    }).then((_response: Response) => {
      return this.processGetErrorLogs(_response);
    });
  }

  protected processGetErrorLogs(response: Response): Promise<AppSettings> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = AppSettings.fromJS(resultData200);
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<AppSettings>(<any>null);
  }
}

export abstract class GdsSessionCustomData implements IGdsSessionCustomData {

  protected _discriminator: string;

  constructor(data?: IGdsSessionCustomData) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
    this._discriminator = "GdsSessionCustomData";
  }

  init(_data?: any) {
  }

  static fromJS(data: any): GdsSessionCustomData {
    data = typeof data === 'object' ? data : {};
    if (data["CustomDataConnectorCode"] === "SABRE") {
      let result = new SabreGdsSessionCustomData();
      result.init(data);
      return result;
    }
    if (data["CustomDataConnectorCode"] === "AMADEUS") {
      let result = new AmadeusGdsSessionCustomData();
      result.init(data);
      return result;
    }
    throw new Error("The abstract class 'GdsSessionCustomData' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["CustomDataConnectorCode"] = this._discriminator;
    return data;
  }
}

export interface IGdsSessionCustomData {
}

export class SabreGdsSessionCustomData extends GdsSessionCustomData implements ISabreGdsSessionCustomData {
  /** Session Id */
  Id?: string | undefined;
  /** Session Type */
  Type?: ESabreSessionType;
  /** Session Environment */
  Environment?: string | undefined;
  /** Session Status */
  Status?: ESabreSessionStatus;
  /** Session Last Call UTC */
  LastCallUtc?: string;
  /** Sabre Binary Security Token -&gt; Passed in the Header of Messages */
  BinarySecurityToken?: string | undefined;
  /** Sabre ConversationId -&gt; If null it'll take the Pid of the request */
  ConversationId?: string | undefined;
  /** Sabre ProcessId -&gt; If null it'll take the Pid of the request */
  ProcessId?: string | undefined;

  constructor(data?: ISabreGdsSessionCustomData) {
    super(data);
    this._discriminator = "SABRE";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.Id = _data["Id"];
      this.Type = _data["Type"];
      this.Environment = _data["Environment"];
      this.Status = _data["Status"];
      this.LastCallUtc = _data["LastCallUtc"];
      this.BinarySecurityToken = _data["BinarySecurityToken"];
      this.ConversationId = _data["ConversationId"];
      this.ProcessId = _data["ProcessId"];
    }
  }

  static fromJS(data: any): SabreGdsSessionCustomData {
    data = typeof data === 'object' ? data : {};
    let result = new SabreGdsSessionCustomData();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Id"] = this.Id;
    data["Type"] = this.Type;
    data["Environment"] = this.Environment;
    data["Status"] = this.Status;
    data["LastCallUtc"] = this.LastCallUtc;
    data["BinarySecurityToken"] = this.BinarySecurityToken;
    data["ConversationId"] = this.ConversationId;
    data["ProcessId"] = this.ProcessId;
    super.toJSON(data);
    return data;
  }
}

export interface ISabreGdsSessionCustomData extends IGdsSessionCustomData {
  /** Session Id */
  Id?: string | undefined;
  /** Session Type */
  Type?: ESabreSessionType;
  /** Session Environment */
  Environment?: string | undefined;
  /** Session Status */
  Status?: ESabreSessionStatus;
  /** Session Last Call UTC */
  LastCallUtc?: string;
  /** Sabre Binary Security Token -&gt; Passed in the Header of Messages */
  BinarySecurityToken?: string | undefined;
  /** Sabre ConversationId -&gt; If null it'll take the Pid of the request */
  ConversationId?: string | undefined;
  /** Sabre ProcessId -&gt; If null it'll take the Pid of the request */
  ProcessId?: string | undefined;
}

export enum ESabreSessionType {
  SESSION = "SESSION",
  TOKEN = "TOKEN",
}

export enum ESabreSessionStatus {
  AVAILABLE = "AVAILABLE",
  BUSY = "BUSY",
  CLOSED = "CLOSED",
}

export class AmadeusGdsSessionCustomData extends GdsSessionCustomData implements IAmadeusGdsSessionCustomData {
  /** Session Id */
  SessionId?: string | undefined;
  /** Session Status */
  SessionStatus?: EAmadeusSessionStatus;
  /** Sequence Number -&gt; Used by Amadeus always incremented */
  SequenceNumber?: number;
  /** Amadeus Security Token */
  SecurityToken?: string | undefined;

  constructor(data?: IAmadeusGdsSessionCustomData) {
    super(data);
    this._discriminator = "AMADEUS";
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.SessionId = _data["SessionId"];
      this.SessionStatus = _data["SessionStatus"];
      this.SequenceNumber = _data["SequenceNumber"];
      this.SecurityToken = _data["SecurityToken"];
    }
  }

  static fromJS(data: any): AmadeusGdsSessionCustomData {
    data = typeof data === 'object' ? data : {};
    let result = new AmadeusGdsSessionCustomData();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["SessionId"] = this.SessionId;
    data["SessionStatus"] = this.SessionStatus;
    data["SequenceNumber"] = this.SequenceNumber;
    data["SecurityToken"] = this.SecurityToken;
    super.toJSON(data);
    return data;
  }
}

export interface IAmadeusGdsSessionCustomData extends IGdsSessionCustomData {
  /** Session Id */
  SessionId?: string | undefined;
  /** Session Status */
  SessionStatus?: EAmadeusSessionStatus;
  /** Sequence Number -&gt; Used by Amadeus always incremented */
  SequenceNumber?: number;
  /** Amadeus Security Token */
  SecurityToken?: string | undefined;
}

export enum EAmadeusSessionStatus {
  START = "START",
  END = "END",
  IN_SERIES = "IN_SERIES",
}

export class SampleRequest implements ISampleRequest {
  Id?: string | undefined;
  SampleType!: string;
  Name?: string | undefined;
  SavedAtUtc?: string;
  RequestJson!: string;

  constructor(data?: ISampleRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.Id = _data["Id"];
      this.SampleType = _data["SampleType"];
      this.Name = _data["Name"];
      this.SavedAtUtc = _data["SavedAtUtc"];
      this.RequestJson = _data["RequestJson"];
    }
  }

  static fromJS(data: any): SampleRequest {
    data = typeof data === 'object' ? data : {};
    let result = new SampleRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Id"] = this.Id;
    data["SampleType"] = this.SampleType;
    data["Name"] = this.Name;
    data["SavedAtUtc"] = this.SavedAtUtc;
    data["RequestJson"] = this.RequestJson;
    return data;
  }
}

export interface ISampleRequest {
  Id?: string | undefined;
  SampleType: string;
  Name?: string | undefined;
  SavedAtUtc?: string;
  RequestJson: string;
}

/** Jupiter User - Dashboard and Api use this user form JWT token */
export class User implements IUser {
  /** User ID */
  Id?: number;
  /** User Name */
  Name?: string | undefined;
  /** User Email */
  Email?: string | undefined;
  /** User Role */
  Role?: ERole;
  /** Dashboard JWT Token */
  Token?: string | undefined;
  /** Dashboard JWT Refresh Token */
  RefreshToken?: string | undefined;
  /** JupiterApi JWT Token */
  ApiToken?: string | undefined;
  /** Last login */
  LastLogin?: string;

  constructor(data?: IUser) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.Id = _data["Id"];
      this.Name = _data["Name"];
      this.Email = _data["Email"];
      this.Role = _data["Role"];
      this.Token = _data["Token"];
      this.RefreshToken = _data["RefreshToken"];
      this.ApiToken = _data["ApiToken"];
      this.LastLogin = _data["LastLogin"];
    }
  }

  static fromJS(data: any): User {
    data = typeof data === 'object' ? data : {};
    let result = new User();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Id"] = this.Id;
    data["Name"] = this.Name;
    data["Email"] = this.Email;
    data["Role"] = this.Role;
    data["Token"] = this.Token;
    data["RefreshToken"] = this.RefreshToken;
    data["ApiToken"] = this.ApiToken;
    data["LastLogin"] = this.LastLogin;
    return data;
  }
}

/** Jupiter User - Dashboard and Api use this user form JWT token */
export interface IUser {
  /** User ID */
  Id?: number;
  /** User Name */
  Name?: string | undefined;
  /** User Email */
  Email?: string | undefined;
  /** User Role */
  Role?: ERole;
  /** Dashboard JWT Token */
  Token?: string | undefined;
  /** Dashboard JWT Refresh Token */
  RefreshToken?: string | undefined;
  /** JupiterApi JWT Token */
  ApiToken?: string | undefined;
  /** Last login */
  LastLogin?: string;
}

export enum ERole {
  ADMIN = "ADMIN",
  API_USER = "API_USER",
  API_LIMIT_ACCESS_USER = "API_LIMIT_ACCESS_USER",
}

export abstract class BaseRQ implements IBaseRQ {

  constructor(data?: IBaseRQ) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
  }

  static fromJS(data: any): BaseRQ {
    data = typeof data === 'object' ? data : {};
    throw new Error("The abstract class 'BaseRQ' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IBaseRQ {
}

export class UserAuthRQ extends BaseRQ implements IUserAuthRQ {
  Email?: string | undefined;
  Password?: string | undefined;

  constructor(data?: IUserAuthRQ) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.Email = _data["Email"];
      this.Password = _data["Password"];
    }
  }

  static fromJS(data: any): UserAuthRQ {
    data = typeof data === 'object' ? data : {};
    let result = new UserAuthRQ();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Email"] = this.Email;
    data["Password"] = this.Password;
    super.toJSON(data);
    return data;
  }
}

export interface IUserAuthRQ extends IBaseRQ {
  Email?: string | undefined;
  Password?: string | undefined;
}

/** Jupiter App Settings */
export class AppSettings implements IAppSettings {
  /** Api Name
   Used in dashboard to show the name, used in logs as index for elastic and other  */
  ApiName?: string | undefined;
  /** Not set this in AppSettings will be rewrite form the startup with the HostingWnvironment */
  HostingEnvironment?: string | undefined;
  /** Default Api Version Used by ApiVersioning Controller */
  DefaultApiVersion?: string | undefined;
  /** Get the Nuget Package Version */
  NugetPackageVersion?: string | undefined;
  /** Published Api Versions */
  PublishedApiVersions?: string[] | undefined;
  /** Enable the Dashboard Single Page Application as Served by the .netCore App */
  EnableDashboardSPA?: boolean;
  /** Enable the Https redirect */
  EnableHTTPSRedirect?: boolean;
  /** DB Connection Settings */
  DbConnectionSettings?: DbConnectionSettings | undefined;
  /** CORS Settings */
  CORSSettings?: CORSSettings | undefined;
  /** JWT Token Settings */
  JwtSettings?: JwtSettings | undefined;
  /** Api Rate Limit Settings */
  ApiRateLimitSettings?: ApiRateLimitSettings | undefined;
  /** Logs Settings */
  LogSettings?: LogSettings | undefined;
  /** ElasticSearch Settings */
  ElasticSearchSettings?: ElasticSearchSettings | undefined;
  /** Connectors Settings */
  Connectors?: AllConnectorsSettings | undefined;
  /** Cache Settings */
  CacheSettings?: CacheSettings | undefined;
  /** Remote Vault for AppSettings Settings */
  RemoteVaultSettings?: RemoteVaultSettings | undefined;
  /** CloudStorage Disk Settings
   Used by  */
  CloudStorageDiskSettings?: CloudStorageDiskSettings | undefined;

  constructor(data?: IAppSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ApiName = _data["ApiName"];
      this.HostingEnvironment = _data["HostingEnvironment"];
      this.DefaultApiVersion = _data["DefaultApiVersion"];
      this.NugetPackageVersion = _data["NugetPackageVersion"];
      if (Array.isArray(_data["PublishedApiVersions"])) {
        this.PublishedApiVersions = [] as any;
        for (let item of _data["PublishedApiVersions"])
          this.PublishedApiVersions!.push(item);
      }
      this.EnableDashboardSPA = _data["EnableDashboardSPA"];
      this.EnableHTTPSRedirect = _data["EnableHTTPSRedirect"];
      this.DbConnectionSettings = _data["DbConnectionSettings"] ? DbConnectionSettings.fromJS(_data["DbConnectionSettings"]) : <any>undefined;
      this.CORSSettings = _data["CORSSettings"] ? CORSSettings.fromJS(_data["CORSSettings"]) : <any>undefined;
      this.JwtSettings = _data["JwtSettings"] ? JwtSettings.fromJS(_data["JwtSettings"]) : <any>undefined;
      this.ApiRateLimitSettings = _data["ApiRateLimitSettings"] ? ApiRateLimitSettings.fromJS(_data["ApiRateLimitSettings"]) : <any>undefined;
      this.LogSettings = _data["LogSettings"] ? LogSettings.fromJS(_data["LogSettings"]) : <any>undefined;
      this.ElasticSearchSettings = _data["ElasticSearchSettings"] ? ElasticSearchSettings.fromJS(_data["ElasticSearchSettings"]) : <any>undefined;
      this.Connectors = _data["Connectors"] ? AllConnectorsSettings.fromJS(_data["Connectors"]) : <any>undefined;
      this.CacheSettings = _data["CacheSettings"] ? CacheSettings.fromJS(_data["CacheSettings"]) : <any>undefined;
      this.RemoteVaultSettings = _data["RemoteVaultSettings"] ? RemoteVaultSettings.fromJS(_data["RemoteVaultSettings"]) : <any>undefined;
      this.CloudStorageDiskSettings = _data["CloudStorageDiskSettings"] ? CloudStorageDiskSettings.fromJS(_data["CloudStorageDiskSettings"]) : <any>undefined;
    }
  }

  static fromJS(data: any): AppSettings {
    data = typeof data === 'object' ? data : {};
    let result = new AppSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["ApiName"] = this.ApiName;
    data["HostingEnvironment"] = this.HostingEnvironment;
    data["DefaultApiVersion"] = this.DefaultApiVersion;
    data["NugetPackageVersion"] = this.NugetPackageVersion;
    if (Array.isArray(this.PublishedApiVersions)) {
      data["PublishedApiVersions"] = [];
      for (let item of this.PublishedApiVersions)
        data["PublishedApiVersions"].push(item);
    }
    data["EnableDashboardSPA"] = this.EnableDashboardSPA;
    data["EnableHTTPSRedirect"] = this.EnableHTTPSRedirect;
    data["DbConnectionSettings"] = this.DbConnectionSettings ? this.DbConnectionSettings.toJSON() : <any>undefined;
    data["CORSSettings"] = this.CORSSettings ? this.CORSSettings.toJSON() : <any>undefined;
    data["JwtSettings"] = this.JwtSettings ? this.JwtSettings.toJSON() : <any>undefined;
    data["ApiRateLimitSettings"] = this.ApiRateLimitSettings ? this.ApiRateLimitSettings.toJSON() : <any>undefined;
    data["LogSettings"] = this.LogSettings ? this.LogSettings.toJSON() : <any>undefined;
    data["ElasticSearchSettings"] = this.ElasticSearchSettings ? this.ElasticSearchSettings.toJSON() : <any>undefined;
    data["Connectors"] = this.Connectors ? this.Connectors.toJSON() : <any>undefined;
    data["CacheSettings"] = this.CacheSettings ? this.CacheSettings.toJSON() : <any>undefined;
    data["RemoteVaultSettings"] = this.RemoteVaultSettings ? this.RemoteVaultSettings.toJSON() : <any>undefined;
    data["CloudStorageDiskSettings"] = this.CloudStorageDiskSettings ? this.CloudStorageDiskSettings.toJSON() : <any>undefined;
    return data;
  }
}

/** Jupiter App Settings */
export interface IAppSettings {
  /** Api Name
   Used in dashboard to show the name, used in logs as index for elastic and other  */
  ApiName?: string | undefined;
  /** Not set this in AppSettings will be rewrite form the startup with the HostingWnvironment */
  HostingEnvironment?: string | undefined;
  /** Default Api Version Used by ApiVersioning Controller */
  DefaultApiVersion?: string | undefined;
  /** Get the Nuget Package Version */
  NugetPackageVersion?: string | undefined;
  /** Published Api Versions */
  PublishedApiVersions?: string[] | undefined;
  /** Enable the Dashboard Single Page Application as Served by the .netCore App */
  EnableDashboardSPA?: boolean;
  /** Enable the Https redirect */
  EnableHTTPSRedirect?: boolean;
  /** DB Connection Settings */
  DbConnectionSettings?: DbConnectionSettings | undefined;
  /** CORS Settings */
  CORSSettings?: CORSSettings | undefined;
  /** JWT Token Settings */
  JwtSettings?: JwtSettings | undefined;
  /** Api Rate Limit Settings */
  ApiRateLimitSettings?: ApiRateLimitSettings | undefined;
  /** Logs Settings */
  LogSettings?: LogSettings | undefined;
  /** ElasticSearch Settings */
  ElasticSearchSettings?: ElasticSearchSettings | undefined;
  /** Connectors Settings */
  Connectors?: AllConnectorsSettings | undefined;
  /** Cache Settings */
  CacheSettings?: CacheSettings | undefined;
  /** Remote Vault for AppSettings Settings */
  RemoteVaultSettings?: RemoteVaultSettings | undefined;
  /** CloudStorage Disk Settings
   Used by  */
  CloudStorageDiskSettings?: CloudStorageDiskSettings | undefined;
}

/** Db Connection Settings Class */
export class DbConnectionSettings implements IDbConnectionSettings {
  /** Db Connection Type */
  Type?: EDbConnectionType;
  /** DB Connection String */
  ConnectionString?: string | undefined;

  constructor(data?: IDbConnectionSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.Type = _data["Type"];
      this.ConnectionString = _data["ConnectionString"];
    }
  }

  static fromJS(data: any): DbConnectionSettings {
    data = typeof data === 'object' ? data : {};
    let result = new DbConnectionSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Type"] = this.Type;
    data["ConnectionString"] = this.ConnectionString;
    return data;
  }
}

/** Db Connection Settings Class */
export interface IDbConnectionSettings {
  /** Db Connection Type */
  Type?: EDbConnectionType;
  /** DB Connection String */
  ConnectionString?: string | undefined;
}

/** Db Connection Type Enum */
export enum EDbConnectionType {
  SQL_LITE = "SQL_LITE",
  MYSQL = "MYSQL",
  SQL_SERVER = "SQL_SERVER",
}

/** CORS Settings Class */
export class CORSSettings implements ICORSSettings {
  /** Dashboard API CORS AllowedOrigins */
  JupiterDashboardApiCorsAllowedOrigins?: string[] | undefined;
  /** Jupiter API CORS AllowedOrigins */
  JupiterApiCorsAllowedOrigins?: string[] | undefined;
  /** Custom CORS Policy Name
   Used in controller as custom policy on methods
   Used to open only some Api methods to specific origins */
  CustomCorsPolicyName?: string | undefined;
  /** Custom CORS AllowedOrigins */
  CustomCorsAllowedOrigins?: string[] | undefined;

  constructor(data?: ICORSSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["JupiterDashboardApiCorsAllowedOrigins"])) {
        this.JupiterDashboardApiCorsAllowedOrigins = [] as any;
        for (let item of _data["JupiterDashboardApiCorsAllowedOrigins"])
          this.JupiterDashboardApiCorsAllowedOrigins!.push(item);
      }
      if (Array.isArray(_data["JupiterApiCorsAllowedOrigins"])) {
        this.JupiterApiCorsAllowedOrigins = [] as any;
        for (let item of _data["JupiterApiCorsAllowedOrigins"])
          this.JupiterApiCorsAllowedOrigins!.push(item);
      }
      this.CustomCorsPolicyName = _data["CustomCorsPolicyName"];
      if (Array.isArray(_data["CustomCorsAllowedOrigins"])) {
        this.CustomCorsAllowedOrigins = [] as any;
        for (let item of _data["CustomCorsAllowedOrigins"])
          this.CustomCorsAllowedOrigins!.push(item);
      }
    }
  }

  static fromJS(data: any): CORSSettings {
    data = typeof data === 'object' ? data : {};
    let result = new CORSSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.JupiterDashboardApiCorsAllowedOrigins)) {
      data["JupiterDashboardApiCorsAllowedOrigins"] = [];
      for (let item of this.JupiterDashboardApiCorsAllowedOrigins)
        data["JupiterDashboardApiCorsAllowedOrigins"].push(item);
    }
    if (Array.isArray(this.JupiterApiCorsAllowedOrigins)) {
      data["JupiterApiCorsAllowedOrigins"] = [];
      for (let item of this.JupiterApiCorsAllowedOrigins)
        data["JupiterApiCorsAllowedOrigins"].push(item);
    }
    data["CustomCorsPolicyName"] = this.CustomCorsPolicyName;
    if (Array.isArray(this.CustomCorsAllowedOrigins)) {
      data["CustomCorsAllowedOrigins"] = [];
      for (let item of this.CustomCorsAllowedOrigins)
        data["CustomCorsAllowedOrigins"].push(item);
    }
    return data;
  }
}

/** CORS Settings Class */
export interface ICORSSettings {
  /** Dashboard API CORS AllowedOrigins */
  JupiterDashboardApiCorsAllowedOrigins?: string[] | undefined;
  /** Jupiter API CORS AllowedOrigins */
  JupiterApiCorsAllowedOrigins?: string[] | undefined;
  /** Custom CORS Policy Name
   Used in controller as custom policy on methods
   Used to open only some Api methods to specific origins */
  CustomCorsPolicyName?: string | undefined;
  /** Custom CORS AllowedOrigins */
  CustomCorsAllowedOrigins?: string[] | undefined;
}

/** JWT Token Settings */
export class JwtSettings implements IJwtSettings {
  /** JWT Secret */
  Secret?: string | undefined;
  /** JWT Token Expire Minutes */
  JwtExpireMinutes?: number;
  /** JWT Refresh Token Expire Minutes */
  JwtRefreshExpireMinutes?: number;
  /** JWT Dashboard Audience */
  JwtDashboardAudience?: string | undefined;
  /** JWT API Audience */
  JwtApiAudience?: string | undefined;
  /** JWT API Issuer */
  JwtApiIssuer?: string | undefined;

  constructor(data?: IJwtSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.Secret = _data["Secret"];
      this.JwtExpireMinutes = _data["JwtExpireMinutes"];
      this.JwtRefreshExpireMinutes = _data["JwtRefreshExpireMinutes"];
      this.JwtDashboardAudience = _data["JwtDashboardAudience"];
      this.JwtApiAudience = _data["JwtApiAudience"];
      this.JwtApiIssuer = _data["JwtApiIssuer"];
    }
  }

  static fromJS(data: any): JwtSettings {
    data = typeof data === 'object' ? data : {};
    let result = new JwtSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Secret"] = this.Secret;
    data["JwtExpireMinutes"] = this.JwtExpireMinutes;
    data["JwtRefreshExpireMinutes"] = this.JwtRefreshExpireMinutes;
    data["JwtDashboardAudience"] = this.JwtDashboardAudience;
    data["JwtApiAudience"] = this.JwtApiAudience;
    data["JwtApiIssuer"] = this.JwtApiIssuer;
    return data;
  }
}

/** JWT Token Settings */
export interface IJwtSettings {
  /** JWT Secret */
  Secret?: string | undefined;
  /** JWT Token Expire Minutes */
  JwtExpireMinutes?: number;
  /** JWT Refresh Token Expire Minutes */
  JwtRefreshExpireMinutes?: number;
  /** JWT Dashboard Audience */
  JwtDashboardAudience?: string | undefined;
  /** JWT API Audience */
  JwtApiAudience?: string | undefined;
  /** JWT API Issuer */
  JwtApiIssuer?: string | undefined;
}

/** API Rate Limits */
export class ApiRateLimitSettings implements IApiRateLimitSettings {
  /** Enable the restriction based on IP */
  EnableIpSafeList?: boolean;
  /** Allowed Remote IPs */
  AllowedRemoteIps?: string[] | undefined;
  /** Whitelist Paths */
  WhitelistPaths?: string[] | undefined;

  constructor(data?: IApiRateLimitSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.EnableIpSafeList = _data["EnableIpSafeList"];
      if (Array.isArray(_data["AllowedRemoteIps"])) {
        this.AllowedRemoteIps = [] as any;
        for (let item of _data["AllowedRemoteIps"])
          this.AllowedRemoteIps!.push(item);
      }
      if (Array.isArray(_data["WhitelistPaths"])) {
        this.WhitelistPaths = [] as any;
        for (let item of _data["WhitelistPaths"])
          this.WhitelistPaths!.push(item);
      }
    }
  }

  static fromJS(data: any): ApiRateLimitSettings {
    data = typeof data === 'object' ? data : {};
    let result = new ApiRateLimitSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["EnableIpSafeList"] = this.EnableIpSafeList;
    if (Array.isArray(this.AllowedRemoteIps)) {
      data["AllowedRemoteIps"] = [];
      for (let item of this.AllowedRemoteIps)
        data["AllowedRemoteIps"].push(item);
    }
    if (Array.isArray(this.WhitelistPaths)) {
      data["WhitelistPaths"] = [];
      for (let item of this.WhitelistPaths)
        data["WhitelistPaths"].push(item);
    }
    return data;
  }
}

/** API Rate Limits */
export interface IApiRateLimitSettings {
  /** Enable the restriction based on IP */
  EnableIpSafeList?: boolean;
  /** Allowed Remote IPs */
  AllowedRemoteIps?: string[] | undefined;
  /** Whitelist Paths */
  WhitelistPaths?: string[] | undefined;
}

/** Log Settings Class */
export class LogSettings implements ILogSettings {
  /** Enabled Log Types */
  EnabledLogTypes?: EJupiterLogType[] | undefined;
  /** If BOOK_CLOUD_STORAGE_LOGS is present
   Also if Connector Remote Call Logs is disabled or the specific operation is disabled it will be logged always
   It will log to the CloudStorageDisk */
  H2HOperationStorageLog?: EH2HOperation[] | undefined;
  /** If BOOK_CLOUD_STORAGE_LOGS is present
   By Default all Service Call Logs with Methods name as H2HOperationStorageLog will be logged
   Add any other Method Name you want to log to the CloudStorageDisk */
  AdditionalServiceCallStorageLog?: string[] | undefined;
  /** Disabled CallLogs Filters
   Used in DefaultJupiterCallLogger to check if the Call should be logged or not
   By Default ERROR status will always be logged */
  DisabledCallLogFilters?: DisabledCallLogFilter[] | undefined;
  /** ApplicationLog Name
   Used for local and for Elasticsearch index */
  ApplicationLogName?: string | undefined;
  /** API Call -&gt; ServiceCallLog Name
   Used for local and for ElasticSearch index */
  ServiceCallLogName?: string | undefined;
  /** Internal H2H Connector call -&gt; ConnectorCall LogName
   Used for local and for ElasticSearch index */
  ConnectorCallLogName?: string | undefined;
  /** External H2H Connector call -&gt; ConnectorRemoteCall LogName
   Used for local and for ElasticSearch index */
  ConnectorRemoteCallName?: string | undefined;
  /** Custom Call -&gt; CustomCall LogName
   Used for local and for ElasticSearch index */
  CustomCallLogName?: string | undefined;
  /** Console Serilog MessageTemplate */
  SerilogMessageTemplate?: string | undefined;
  /** Local Log Path */
  LocalLogsBasePath?: string | undefined;
  /** Get the full path for ApplicationLogLocalDirectory
   if Enable AzureDiagnosticLogStream -&gt; will use the specific path of Azure */
  ApplicationLogLocalDirectory?: string | undefined;
  /** Get the full path for ServiceCallLogLocalDirectory
   if Enable AzureDiagnosticLogStream -&gt; will use the specific path of Azure */
  ServiceCallLogLocalDirectory?: string | undefined;
  /** Get the full path for ConnectorCallLogLocalDirectory
   if Enable AzureDiagnosticLogStream -&gt; will use the specific path of Azure */
  ConnectorCallLogLocalDirectory?: string | undefined;
  /** Get the full path for ConnectorRemoteCallLogDirectory
   if Enable AzureDiagnosticLogStream -&gt; will use the specific path of Azure */
  ConnectorRemoteCallLogDirectory?: string | undefined;
  /** Get the full path for CustomCallLogDirectorya
   if Enable AzureDiagnosticLogStream -&gt; will use the specific path of Azure */
  CustomCallLogDirectory?: string | undefined;

  constructor(data?: ILogSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["EnabledLogTypes"])) {
        this.EnabledLogTypes = [] as any;
        for (let item of _data["EnabledLogTypes"])
          this.EnabledLogTypes!.push(item);
      }
      if (Array.isArray(_data["H2HOperationStorageLog"])) {
        this.H2HOperationStorageLog = [] as any;
        for (let item of _data["H2HOperationStorageLog"])
          this.H2HOperationStorageLog!.push(item);
      }
      if (Array.isArray(_data["AdditionalServiceCallStorageLog"])) {
        this.AdditionalServiceCallStorageLog = [] as any;
        for (let item of _data["AdditionalServiceCallStorageLog"])
          this.AdditionalServiceCallStorageLog!.push(item);
      }
      if (Array.isArray(_data["DisabledCallLogFilters"])) {
        this.DisabledCallLogFilters = [] as any;
        for (let item of _data["DisabledCallLogFilters"])
          this.DisabledCallLogFilters!.push(DisabledCallLogFilter.fromJS(item));
      }
      this.ApplicationLogName = _data["ApplicationLogName"];
      this.ServiceCallLogName = _data["ServiceCallLogName"];
      this.ConnectorCallLogName = _data["ConnectorCallLogName"];
      this.ConnectorRemoteCallName = _data["ConnectorRemoteCallName"];
      this.CustomCallLogName = _data["CustomCallLogName"];
      this.SerilogMessageTemplate = _data["SerilogMessageTemplate"];
      this.LocalLogsBasePath = _data["LocalLogsBasePath"];
      this.ApplicationLogLocalDirectory = _data["ApplicationLogLocalDirectory"];
      this.ServiceCallLogLocalDirectory = _data["ServiceCallLogLocalDirectory"];
      this.ConnectorCallLogLocalDirectory = _data["ConnectorCallLogLocalDirectory"];
      this.ConnectorRemoteCallLogDirectory = _data["ConnectorRemoteCallLogDirectory"];
      this.CustomCallLogDirectory = _data["CustomCallLogDirectory"];
    }
  }

  static fromJS(data: any): LogSettings {
    data = typeof data === 'object' ? data : {};
    let result = new LogSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.EnabledLogTypes)) {
      data["EnabledLogTypes"] = [];
      for (let item of this.EnabledLogTypes)
        data["EnabledLogTypes"].push(item);
    }
    if (Array.isArray(this.H2HOperationStorageLog)) {
      data["H2HOperationStorageLog"] = [];
      for (let item of this.H2HOperationStorageLog)
        data["H2HOperationStorageLog"].push(item);
    }
    if (Array.isArray(this.AdditionalServiceCallStorageLog)) {
      data["AdditionalServiceCallStorageLog"] = [];
      for (let item of this.AdditionalServiceCallStorageLog)
        data["AdditionalServiceCallStorageLog"].push(item);
    }
    if (Array.isArray(this.DisabledCallLogFilters)) {
      data["DisabledCallLogFilters"] = [];
      for (let item of this.DisabledCallLogFilters)
        data["DisabledCallLogFilters"].push(item.toJSON());
    }
    data["ApplicationLogName"] = this.ApplicationLogName;
    data["ServiceCallLogName"] = this.ServiceCallLogName;
    data["ConnectorCallLogName"] = this.ConnectorCallLogName;
    data["ConnectorRemoteCallName"] = this.ConnectorRemoteCallName;
    data["CustomCallLogName"] = this.CustomCallLogName;
    data["SerilogMessageTemplate"] = this.SerilogMessageTemplate;
    data["LocalLogsBasePath"] = this.LocalLogsBasePath;
    data["ApplicationLogLocalDirectory"] = this.ApplicationLogLocalDirectory;
    data["ServiceCallLogLocalDirectory"] = this.ServiceCallLogLocalDirectory;
    data["ConnectorCallLogLocalDirectory"] = this.ConnectorCallLogLocalDirectory;
    data["ConnectorRemoteCallLogDirectory"] = this.ConnectorRemoteCallLogDirectory;
    data["CustomCallLogDirectory"] = this.CustomCallLogDirectory;
    return data;
  }
}

/** Log Settings Class */
export interface ILogSettings {
  /** Enabled Log Types */
  EnabledLogTypes?: EJupiterLogType[] | undefined;
  /** If BOOK_CLOUD_STORAGE_LOGS is present
   Also if Connector Remote Call Logs is disabled or the specific operation is disabled it will be logged always
   It will log to the CloudStorageDisk */
  H2HOperationStorageLog?: EH2HOperation[] | undefined;
  /** If BOOK_CLOUD_STORAGE_LOGS is present
   By Default all Service Call Logs with Methods name as H2HOperationStorageLog will be logged
   Add any other Method Name you want to log to the CloudStorageDisk */
  AdditionalServiceCallStorageLog?: string[] | undefined;
  /** Disabled CallLogs Filters
   Used in DefaultJupiterCallLogger to check if the Call should be logged or not
   By Default ERROR status will always be logged */
  DisabledCallLogFilters?: DisabledCallLogFilter[] | undefined;
  /** ApplicationLog Name
   Used for local and for Elasticsearch index */
  ApplicationLogName?: string | undefined;
  /** API Call -&gt; ServiceCallLog Name
   Used for local and for ElasticSearch index */
  ServiceCallLogName?: string | undefined;
  /** Internal H2H Connector call -&gt; ConnectorCall LogName
   Used for local and for ElasticSearch index */
  ConnectorCallLogName?: string | undefined;
  /** External H2H Connector call -&gt; ConnectorRemoteCall LogName
   Used for local and for ElasticSearch index */
  ConnectorRemoteCallName?: string | undefined;
  /** Custom Call -&gt; CustomCall LogName
   Used for local and for ElasticSearch index */
  CustomCallLogName?: string | undefined;
  /** Console Serilog MessageTemplate */
  SerilogMessageTemplate?: string | undefined;
  /** Local Log Path */
  LocalLogsBasePath?: string | undefined;
  /** Get the full path for ApplicationLogLocalDirectory
   if Enable AzureDiagnosticLogStream -&gt; will use the specific path of Azure */
  ApplicationLogLocalDirectory?: string | undefined;
  /** Get the full path for ServiceCallLogLocalDirectory
   if Enable AzureDiagnosticLogStream -&gt; will use the specific path of Azure */
  ServiceCallLogLocalDirectory?: string | undefined;
  /** Get the full path for ConnectorCallLogLocalDirectory
   if Enable AzureDiagnosticLogStream -&gt; will use the specific path of Azure */
  ConnectorCallLogLocalDirectory?: string | undefined;
  /** Get the full path for ConnectorRemoteCallLogDirectory
   if Enable AzureDiagnosticLogStream -&gt; will use the specific path of Azure */
  ConnectorRemoteCallLogDirectory?: string | undefined;
  /** Get the full path for CustomCallLogDirectorya
   if Enable AzureDiagnosticLogStream -&gt; will use the specific path of Azure */
  CustomCallLogDirectory?: string | undefined;
}

/** Cache Type Enum */
export enum EJupiterLogType {
  CALL_LOGS_API_SERVICE = "CALL_LOGS_API_SERVICE",
  CALL_LOGS_CONNECTOR_REMOTE = "CALL_LOGS_CONNECTOR_REMOTE",
  CALL_LOGS_CUSTOM = "CALL_LOGS_CUSTOM",
  CALL_LOGS_INTERNAL_CONNECTOR = "CALL_LOGS_INTERNAL_CONNECTOR",
  LOCAL_APPLICATION_LOGS = "LOCAL_APPLICATION_LOGS",
  LOCAL_CALL_LOGS = "LOCAL_CALL_LOGS",
  CONSOLE_LOGS = "CONSOLE_LOGS",
  ELASTIC_APPLICATION_LOGS = "ELASTIC_APPLICATION_LOGS",
  ELASTIC_ERROR_LOGS = "ELASTIC_ERROR_LOGS",
  ELASTIC_CALL_LOGS = "ELASTIC_CALL_LOGS",
  ELASTIC_CALL_METRICS = "ELASTIC_CALL_METRICS",
  ELASTIC_APM = "ELASTIC_APM",
  AZURE_DIAGNOSTIC_LOG_STREAM = "AZURE_DIAGNOSTIC_LOG_STREAM",
  BOOK_CLOUD_STORAGE_LOGS = "BOOK_CLOUD_STORAGE_LOGS",
}

export enum EH2HOperation {
  HOTEL_DETAILS = "HOTEL_DETAILS",
  HOTEL_AVAIL = "HOTEL_AVAIL",
  HOTEL_AVAIL_CALENDAR = "HOTEL_AVAIL_CALENDAR",
  HOTEL_AVAIL_SINGLE = "HOTEL_AVAIL_SINGLE",
  HOTEL_AVAIL_EXTRAS = "HOTEL_AVAIL_EXTRAS",
  HOTEL_GET_CANCEL_POLICY = "HOTEL_GET_CANCEL_POLICY",
  HOTEL_PRICE_VERIFY = "HOTEL_PRICE_VERIFY",
  HOTEL_BOOK = "HOTEL_BOOK",
  HOTEL_BOOK_ADD = "HOTEL_BOOK_ADD",
  HOTEL_BOOK_DETAIL = "HOTEL_BOOK_DETAIL",
  HOTEL_BOOK_VERIFY = "HOTEL_BOOK_VERIFY",
  HOTEL_BOOK_SEARCH = "HOTEL_BOOK_SEARCH",
  HOTEL_BOOK_MODIFY = "HOTEL_BOOK_MODIFY",
  HOTEL_BOOK_CANCEL = "HOTEL_BOOK_CANCEL",
  HOTEL_CHAIN_LIST = "HOTEL_CHAIN_LIST",
  HOTEL_CHAIN_DETAIL = "HOTEL_CHAIN_DETAIL",
  PING = "PING",
  SESSION_CREATE = "SESSION_CREATE",
  SESSION_CLOSE = "SESSION_CLOSE",
  SESSION_REFRESH = "SESSION_REFRESH",
  SESSION_TOKEN_CREATE = "SESSION_TOKEN_CREATE",
  IGNORE_TRANSACTION = "IGNORE_TRANSACTION",
  CRYPTIC = "CRYPTIC",
  FLIGHT_AVAIL = "FLIGHT_AVAIL",
  FLIGHT_DETAILS = "FLIGHT_DETAILS",
  FLIGHT_PRICE_VERIFY = "FLIGHT_PRICE_VERIFY",
  FLIGHT_BOOK = "FLIGHT_BOOK",
  FLIGHT_PNR_RETRIEVE = "FLIGHT_PNR_RETRIEVE",
  TRAIN_AVAIL = "TRAIN_AVAIL",
  TRAIN_BOOK = "TRAIN_BOOK",
  DESTINATION_LIST = "DESTINATION_LIST",
  CONNECTOR_CUSTOM = "CONNECTOR_CUSTOM",
}

/** Disabled CallLog Filter */
export class DisabledCallLogFilter implements IDisabledCallLogFilter {
  /** Call Log Type */
  LogTypes?: EJupiterLogType[] | undefined;
  /** Call Pid StartWith */
  PidStartWith?: string | undefined;
  /** Operation Status
   ERROR Status will always be logged */
  Status?: EOperationStatus | undefined;
  /** ConnectorCode */
  ConnectorCode?: EH2HConnectorCode | undefined;
  /** ConnectorOperation */
  ConnectorOperation?: EH2HOperation | undefined;

  constructor(data?: IDisabledCallLogFilter) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["LogTypes"])) {
        this.LogTypes = [] as any;
        for (let item of _data["LogTypes"])
          this.LogTypes!.push(item);
      }
      this.PidStartWith = _data["PidStartWith"];
      this.Status = _data["Status"];
      this.ConnectorCode = _data["ConnectorCode"];
      this.ConnectorOperation = _data["ConnectorOperation"];
    }
  }

  static fromJS(data: any): DisabledCallLogFilter {
    data = typeof data === 'object' ? data : {};
    let result = new DisabledCallLogFilter();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.LogTypes)) {
      data["LogTypes"] = [];
      for (let item of this.LogTypes)
        data["LogTypes"].push(item);
    }
    data["PidStartWith"] = this.PidStartWith;
    data["Status"] = this.Status;
    data["ConnectorCode"] = this.ConnectorCode;
    data["ConnectorOperation"] = this.ConnectorOperation;
    return data;
  }
}

/** Disabled CallLog Filter */
export interface IDisabledCallLogFilter {
  /** Call Log Type */
  LogTypes?: EJupiterLogType[] | undefined;
  /** Call Pid StartWith */
  PidStartWith?: string | undefined;
  /** Operation Status
   ERROR Status will always be logged */
  Status?: EOperationStatus | undefined;
  /** ConnectorCode */
  ConnectorCode?: EH2HConnectorCode | undefined;
  /** ConnectorOperation */
  ConnectorOperation?: EH2HOperation | undefined;
}

export enum EOperationStatus {
  SUCCESS = "SUCCESS",
  WARNING = "WARNING",
  ERROR = "ERROR",
}

export enum EH2HConnectorCode {
  UNKNOWN = "UNKNOWN",
  BOOKING_DOT_COM = "BOOKING_DOT_COM",
  SABRE_SYNXIS = "SABRE_SYNXIS",
  AMADEUS = "AMADEUS",
  SABRE = "SABRE",
  SABRE_CSL = "SABRE_CSL",
  CREOLE = "CREOLE",
  SANDALS = "SANDALS",
  TRAVELFUSION = "TRAVELFUSION",
  IHG_GRS = "IHG_GRS",
  OKKAMI = "OKKAMI",
  HOTELBEDS = "HOTELBEDS",
  EMINDS = "EMINDS",
  EXPEDIA = "EXPEDIA",
  A_SAMPLE = "A_SAMPLE",
}

/** ElasticSearch Settings Class */
export class ElasticSearchSettings implements IElasticSearchSettings {
  /** ElasticSearch URL */
  Url?: string | undefined;
  /** ElasticSearch User if needed */
  User?: string | undefined;
  /** ElasticSearch Password if needed */
  Password?: string | undefined;
  /** Elastic Suffix index format for Call Logs
   Default Monthly "-{0:yyyy.MM}"
   For a Dayly "-{0:yyyy.MM.dd}" */
  CallLogsSuffixIndexFormat?: string | undefined;
  /** Elastic Suffix index format for Metrics Call Logs
   Default Monthly "-{0:yyyy.MM}"
   For a Dayly "-{0:yyyy.MM.dd}" */
  MetricsCallLogsSuffixIndexFormat?: string | undefined;
  /** Elastic Suffix index format for Application and Error Logs
   Default Monthly "-{0:yyyy.MM}"
   For a Dayly "-{0:yyyy.MM.dd}" */
  ApplicationLogsSuffixIndexFormat?: string | undefined;
  /** Kibana URL */
  KibanaUrl?: string | undefined;

  constructor(data?: IElasticSearchSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.Url = _data["Url"];
      this.User = _data["User"];
      this.Password = _data["Password"];
      this.CallLogsSuffixIndexFormat = _data["CallLogsSuffixIndexFormat"];
      this.MetricsCallLogsSuffixIndexFormat = _data["MetricsCallLogsSuffixIndexFormat"];
      this.ApplicationLogsSuffixIndexFormat = _data["ApplicationLogsSuffixIndexFormat"];
      this.KibanaUrl = _data["KibanaUrl"];
    }
  }

  static fromJS(data: any): ElasticSearchSettings {
    data = typeof data === 'object' ? data : {};
    let result = new ElasticSearchSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Url"] = this.Url;
    data["User"] = this.User;
    data["Password"] = this.Password;
    data["CallLogsSuffixIndexFormat"] = this.CallLogsSuffixIndexFormat;
    data["MetricsCallLogsSuffixIndexFormat"] = this.MetricsCallLogsSuffixIndexFormat;
    data["ApplicationLogsSuffixIndexFormat"] = this.ApplicationLogsSuffixIndexFormat;
    data["KibanaUrl"] = this.KibanaUrl;
    return data;
  }
}

/** ElasticSearch Settings Class */
export interface IElasticSearchSettings {
  /** ElasticSearch URL */
  Url?: string | undefined;
  /** ElasticSearch User if needed */
  User?: string | undefined;
  /** ElasticSearch Password if needed */
  Password?: string | undefined;
  /** Elastic Suffix index format for Call Logs
   Default Monthly "-{0:yyyy.MM}"
   For a Dayly "-{0:yyyy.MM.dd}" */
  CallLogsSuffixIndexFormat?: string | undefined;
  /** Elastic Suffix index format for Metrics Call Logs
   Default Monthly "-{0:yyyy.MM}"
   For a Dayly "-{0:yyyy.MM.dd}" */
  MetricsCallLogsSuffixIndexFormat?: string | undefined;
  /** Elastic Suffix index format for Application and Error Logs
   Default Monthly "-{0:yyyy.MM}"
   For a Dayly "-{0:yyyy.MM.dd}" */
  ApplicationLogsSuffixIndexFormat?: string | undefined;
  /** Kibana URL */
  KibanaUrl?: string | undefined;
}

/** Connector Settings */
export class AllConnectorsSettings implements IAllConnectorsSettings {
  /** Enabled Connectors */
  EnabledConnectors?: EH2HConnectorCode[] | undefined;
  /** Default Connectors Environment */
  DefaultConnectorsEnvironment?: ConnectorEnvironment[] | undefined;
  /** List of Single Connector Settings */
  ConnectorSettings?: BaseConnectorSettings[] | undefined;

  constructor(data?: IAllConnectorsSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["EnabledConnectors"])) {
        this.EnabledConnectors = [] as any;
        for (let item of _data["EnabledConnectors"])
          this.EnabledConnectors!.push(item);
      }
      if (Array.isArray(_data["DefaultConnectorsEnvironment"])) {
        this.DefaultConnectorsEnvironment = [] as any;
        for (let item of _data["DefaultConnectorsEnvironment"])
          this.DefaultConnectorsEnvironment!.push(ConnectorEnvironment.fromJS(item));
      }
      if (Array.isArray(_data["ConnectorSettings"])) {
        this.ConnectorSettings = [] as any;
        for (let item of _data["ConnectorSettings"])
          this.ConnectorSettings!.push(BaseConnectorSettings.fromJS(item));
      }
    }
  }

  static fromJS(data: any): AllConnectorsSettings {
    data = typeof data === 'object' ? data : {};
    let result = new AllConnectorsSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.EnabledConnectors)) {
      data["EnabledConnectors"] = [];
      for (let item of this.EnabledConnectors)
        data["EnabledConnectors"].push(item);
    }
    if (Array.isArray(this.DefaultConnectorsEnvironment)) {
      data["DefaultConnectorsEnvironment"] = [];
      for (let item of this.DefaultConnectorsEnvironment)
        data["DefaultConnectorsEnvironment"].push(item.toJSON());
    }
    if (Array.isArray(this.ConnectorSettings)) {
      data["ConnectorSettings"] = [];
      for (let item of this.ConnectorSettings)
        data["ConnectorSettings"].push(item.toJSON());
    }
    return data;
  }
}

/** Connector Settings */
export interface IAllConnectorsSettings {
  /** Enabled Connectors */
  EnabledConnectors?: EH2HConnectorCode[] | undefined;
  /** Default Connectors Environment */
  DefaultConnectorsEnvironment?: ConnectorEnvironment[] | undefined;
  /** List of Single Connector Settings */
  ConnectorSettings?: BaseConnectorSettings[] | undefined;
}

export class ConnectorEnvironment implements IConnectorEnvironment {
  /** Connector Code */
  ConnectorCode?: EH2HConnectorCode;
  /** Default Environment */
  Environment?: string | undefined;

  constructor(data?: IConnectorEnvironment) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ConnectorCode = _data["ConnectorCode"];
      this.Environment = _data["Environment"];
    }
  }

  static fromJS(data: any): ConnectorEnvironment {
    data = typeof data === 'object' ? data : {};
    let result = new ConnectorEnvironment();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["ConnectorCode"] = this.ConnectorCode;
    data["Environment"] = this.Environment;
    return data;
  }
}

export interface IConnectorEnvironment {
  /** Connector Code */
  ConnectorCode?: EH2HConnectorCode;
  /** Default Environment */
  Environment?: string | undefined;
}

export class BaseConnectorSettings implements IBaseConnectorSettings {
  /** Connector Code */
  ConnectorCode?: EH2HConnectorCode;
  /** Environment Key
   Used to add multiple times the same connector with different settings */
  Environment?: string | undefined;
  /** Connector Endpoint */
  Endpoint?: string | undefined;
  /** Disabled Connector Types */
  DisabledConnectorTypes?: EH2HConnectorType[] | undefined;
  /** Disabled Operations */
  DisabledOperations?: EH2HOperation[] | undefined;
  /** Not set this in AppSettings will be rewrite form BaseConnector constructor */
  Version?: string | undefined;
  /** Return if the current Environment is the default for the Connector
   Not set this in AppSettings will be rewrite form BaseConnector constructor */
  IsDefaultEnvironment?: boolean;
  /** Not set this in AppSettings will be rewrite form BaseConnector constructor */
  EnabledConnectorTypes?: EH2HConnectorType[] | undefined;
  /** Not set this in AppSettings will be rewrite form BaseConnector constructor */
  EnabledOperations?: EH2HOperation[] | undefined;

  constructor(data?: IBaseConnectorSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ConnectorCode = _data["ConnectorCode"];
      this.Environment = _data["Environment"];
      this.Endpoint = _data["Endpoint"];
      if (Array.isArray(_data["DisabledConnectorTypes"])) {
        this.DisabledConnectorTypes = [] as any;
        for (let item of _data["DisabledConnectorTypes"])
          this.DisabledConnectorTypes!.push(item);
      }
      if (Array.isArray(_data["DisabledOperations"])) {
        this.DisabledOperations = [] as any;
        for (let item of _data["DisabledOperations"])
          this.DisabledOperations!.push(item);
      }
      this.Version = _data["Version"];
      this.IsDefaultEnvironment = _data["IsDefaultEnvironment"];
      if (Array.isArray(_data["EnabledConnectorTypes"])) {
        this.EnabledConnectorTypes = [] as any;
        for (let item of _data["EnabledConnectorTypes"])
          this.EnabledConnectorTypes!.push(item);
      }
      if (Array.isArray(_data["EnabledOperations"])) {
        this.EnabledOperations = [] as any;
        for (let item of _data["EnabledOperations"])
          this.EnabledOperations!.push(item);
      }
    }
  }

  static fromJS(data: any): BaseConnectorSettings {
    data = typeof data === 'object' ? data : {};
    let result = new BaseConnectorSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["ConnectorCode"] = this.ConnectorCode;
    data["Environment"] = this.Environment;
    data["Endpoint"] = this.Endpoint;
    if (Array.isArray(this.DisabledConnectorTypes)) {
      data["DisabledConnectorTypes"] = [];
      for (let item of this.DisabledConnectorTypes)
        data["DisabledConnectorTypes"].push(item);
    }
    if (Array.isArray(this.DisabledOperations)) {
      data["DisabledOperations"] = [];
      for (let item of this.DisabledOperations)
        data["DisabledOperations"].push(item);
    }
    data["Version"] = this.Version;
    data["IsDefaultEnvironment"] = this.IsDefaultEnvironment;
    if (Array.isArray(this.EnabledConnectorTypes)) {
      data["EnabledConnectorTypes"] = [];
      for (let item of this.EnabledConnectorTypes)
        data["EnabledConnectorTypes"].push(item);
    }
    if (Array.isArray(this.EnabledOperations)) {
      data["EnabledOperations"] = [];
      for (let item of this.EnabledOperations)
        data["EnabledOperations"].push(item);
    }
    return data;
  }
}

export interface IBaseConnectorSettings {
  /** Connector Code */
  ConnectorCode?: EH2HConnectorCode;
  /** Environment Key
   Used to add multiple times the same connector with different settings */
  Environment?: string | undefined;
  /** Connector Endpoint */
  Endpoint?: string | undefined;
  /** Disabled Connector Types */
  DisabledConnectorTypes?: EH2HConnectorType[] | undefined;
  /** Disabled Operations */
  DisabledOperations?: EH2HOperation[] | undefined;
  /** Not set this in AppSettings will be rewrite form BaseConnector constructor */
  Version?: string | undefined;
  /** Return if the current Environment is the default for the Connector
   Not set this in AppSettings will be rewrite form BaseConnector constructor */
  IsDefaultEnvironment?: boolean;
  /** Not set this in AppSettings will be rewrite form BaseConnector constructor */
  EnabledConnectorTypes?: EH2HConnectorType[] | undefined;
  /** Not set this in AppSettings will be rewrite form BaseConnector constructor */
  EnabledOperations?: EH2HOperation[] | undefined;
}

export enum EH2HConnectorType {
  HOTEL = "HOTEL",
  FLIGHT = "FLIGHT",
  SESSION_AND_CRYPTIC = "SESSION_AND_CRYPTIC",
  TOUR = "TOUR",
  TRAIN = "TRAIN",
  FERRIES = "FERRIES",
  DESTINATION = "DESTINATION",
}

/** Cache Settings Class */
export class CacheSettings implements ICacheSettings {
  /** Cache Type */
  Type?: ECacheType;
  /** Redis Settings */
  RedisSettings?: RedisSettings | undefined;

  constructor(data?: ICacheSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.Type = _data["Type"];
      this.RedisSettings = _data["RedisSettings"] ? RedisSettings.fromJS(_data["RedisSettings"]) : <any>undefined;
    }
  }

  static fromJS(data: any): CacheSettings {
    data = typeof data === 'object' ? data : {};
    let result = new CacheSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Type"] = this.Type;
    data["RedisSettings"] = this.RedisSettings ? this.RedisSettings.toJSON() : <any>undefined;
    return data;
  }
}

/** Cache Settings Class */
export interface ICacheSettings {
  /** Cache Type */
  Type?: ECacheType;
  /** Redis Settings */
  RedisSettings?: RedisSettings | undefined;
}

/** Cache Type Enum */
export enum ECacheType {
  IN_MEMORY = "IN_MEMORY",
  REDIS = "REDIS",
}

/** Redis Settings */
export class RedisSettings implements IRedisSettings {
  /** Redis Configuration Endpoint */
  Configuration?: string | undefined;
  /** Redis Instance Name */
  InstanceName?: string | undefined;

  constructor(data?: IRedisSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.Configuration = _data["Configuration"];
      this.InstanceName = _data["InstanceName"];
    }
  }

  static fromJS(data: any): RedisSettings {
    data = typeof data === 'object' ? data : {};
    let result = new RedisSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Configuration"] = this.Configuration;
    data["InstanceName"] = this.InstanceName;
    return data;
  }
}

/** Redis Settings */
export interface IRedisSettings {
  /** Redis Configuration Endpoint */
  Configuration?: string | undefined;
  /** Redis Instance Name */
  InstanceName?: string | undefined;
}

/** Remote Vault Settings Class */
export class RemoteVaultSettings implements IRemoteVaultSettings {
  /** RemoteVault Type */
  Type?: ERemoteVaultType;
  /** Azure KeyVault Settings */
  AzureKeyVaultSettings?: AzureKeyVaultSettings | undefined;
  /** Gcp Secrets Settings */
  GcpSecretsSettings?: GcpSecretsSettings | undefined;

  constructor(data?: IRemoteVaultSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.Type = _data["Type"];
      this.AzureKeyVaultSettings = _data["AzureKeyVaultSettings"] ? AzureKeyVaultSettings.fromJS(_data["AzureKeyVaultSettings"]) : <any>undefined;
      this.GcpSecretsSettings = _data["GcpSecretsSettings"] ? GcpSecretsSettings.fromJS(_data["GcpSecretsSettings"]) : <any>undefined;
    }
  }

  static fromJS(data: any): RemoteVaultSettings {
    data = typeof data === 'object' ? data : {};
    let result = new RemoteVaultSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Type"] = this.Type;
    data["AzureKeyVaultSettings"] = this.AzureKeyVaultSettings ? this.AzureKeyVaultSettings.toJSON() : <any>undefined;
    data["GcpSecretsSettings"] = this.GcpSecretsSettings ? this.GcpSecretsSettings.toJSON() : <any>undefined;
    return data;
  }
}

/** Remote Vault Settings Class */
export interface IRemoteVaultSettings {
  /** RemoteVault Type */
  Type?: ERemoteVaultType;
  /** Azure KeyVault Settings */
  AzureKeyVaultSettings?: AzureKeyVaultSettings | undefined;
  /** Gcp Secrets Settings */
  GcpSecretsSettings?: GcpSecretsSettings | undefined;
}

/** Remote Vault Type Enum */
export enum ERemoteVaultType {
  AZURE_KEY_VAULT = "AZURE_KEY_VAULT",
  GCP_SECRETS = "GCP_SECRETS",
}

/** Azure KeyVault Settings */
export class AzureKeyVaultSettings implements IAzureKeyVaultSettings {
  Endpoint?: string | undefined;
  SecretKey?: string | undefined;

  constructor(data?: IAzureKeyVaultSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.Endpoint = _data["Endpoint"];
      this.SecretKey = _data["SecretKey"];
    }
  }

  static fromJS(data: any): AzureKeyVaultSettings {
    data = typeof data === 'object' ? data : {};
    let result = new AzureKeyVaultSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Endpoint"] = this.Endpoint;
    data["SecretKey"] = this.SecretKey;
    return data;
  }
}

/** Azure KeyVault Settings */
export interface IAzureKeyVaultSettings {
  Endpoint?: string | undefined;
  SecretKey?: string | undefined;
}

/** Gcp Secrets Settings */
export class GcpSecretsSettings implements IGcpSecretsSettings {
  /** GCP Project ID  */
  ProjectId?: string | undefined;
  SecretId?: string | undefined;
  SecretVersionId?: string | undefined;

  constructor(data?: IGcpSecretsSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ProjectId = _data["ProjectId"];
      this.SecretId = _data["SecretId"];
      this.SecretVersionId = _data["SecretVersionId"];
    }
  }

  static fromJS(data: any): GcpSecretsSettings {
    data = typeof data === 'object' ? data : {};
    let result = new GcpSecretsSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["ProjectId"] = this.ProjectId;
    data["SecretId"] = this.SecretId;
    data["SecretVersionId"] = this.SecretVersionId;
    return data;
  }
}

/** Gcp Secrets Settings */
export interface IGcpSecretsSettings {
  /** GCP Project ID  */
  ProjectId?: string | undefined;
  SecretId?: string | undefined;
  SecretVersionId?: string | undefined;
}

/** Cloud Storage Disk Settings */
export class CloudStorageDiskSettings implements ICloudStorageDiskSettings {
  /** The Cloud Storage Type */
  CloudStorageType?: ECloudStorageType;
  /** Azure Blob Storage Settings */
  AzureBlobStorageSettings?: AzureBlobStorageSettings | undefined;

  constructor(data?: ICloudStorageDiskSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.CloudStorageType = _data["CloudStorageType"];
      this.AzureBlobStorageSettings = _data["AzureBlobStorageSettings"] ? AzureBlobStorageSettings.fromJS(_data["AzureBlobStorageSettings"]) : <any>undefined;
    }
  }

  static fromJS(data: any): CloudStorageDiskSettings {
    data = typeof data === 'object' ? data : {};
    let result = new CloudStorageDiskSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["CloudStorageType"] = this.CloudStorageType;
    data["AzureBlobStorageSettings"] = this.AzureBlobStorageSettings ? this.AzureBlobStorageSettings.toJSON() : <any>undefined;
    return data;
  }
}

/** Cloud Storage Disk Settings */
export interface ICloudStorageDiskSettings {
  /** The Cloud Storage Type */
  CloudStorageType?: ECloudStorageType;
  /** Azure Blob Storage Settings */
  AzureBlobStorageSettings?: AzureBlobStorageSettings | undefined;
}

/** Cache Type Enum */
export enum ECloudStorageType {
  AZURE_BLOB_STORAGE = "AZURE_BLOB_STORAGE",
}

/** Azure Blob Storage Settings */
export class AzureBlobStorageSettings implements IAzureBlobStorageSettings {
  /** Azure Blob connection string */
  ConnectionString?: string | undefined;
  /** Default Connector Log Container Name */
  DefaultCallLogsContainerName?: string | undefined;

  constructor(data?: IAzureBlobStorageSettings) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ConnectionString = _data["ConnectionString"];
      this.DefaultCallLogsContainerName = _data["DefaultCallLogsContainerName"];
    }
  }

  static fromJS(data: any): AzureBlobStorageSettings {
    data = typeof data === 'object' ? data : {};
    let result = new AzureBlobStorageSettings();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["ConnectionString"] = this.ConnectionString;
    data["DefaultCallLogsContainerName"] = this.DefaultCallLogsContainerName;
    return data;
  }
}

/** Azure Blob Storage Settings */
export interface IAzureBlobStorageSettings {
  /** Azure Blob connection string */
  ConnectionString?: string | undefined;
  /** Default Connector Log Container Name */
  DefaultCallLogsContainerName?: string | undefined;
}

/** Published Routes used by dashboard */
export class PublishedRoute implements IPublishedRoute {
  /** Route Name */
  Name?: string | undefined;
  /** Method GET, POST, etc */
  Method?: string | undefined;
  /** PATH of the route */
  Path?: string | undefined;
  /** Full Path Template with {} */
  PathTemplate?: string | undefined;
  Invocation?: string | undefined;
  /** Controller of the method */
  Controller?: string | undefined;
  /** Request Type Full Name if any */
  RequestTypeFullName?: string | undefined;
  /** Response Type Full Name if any */
  ResponseTypeFullName?: string | undefined;
  /** Request Type Name if any */
  RequestType?: string | undefined;
  /** Response Type Name if any */
  ResponseType?: string | undefined;
  /** Secured string -&gt; [ADMIN, API_USER] */
  Authorization?: string[] | undefined;

  constructor(data?: IPublishedRoute) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.Name = _data["Name"];
      this.Method = _data["Method"];
      this.Path = _data["Path"];
      this.PathTemplate = _data["PathTemplate"];
      this.Invocation = _data["Invocation"];
      this.Controller = _data["Controller"];
      this.RequestTypeFullName = _data["RequestTypeFullName"];
      this.ResponseTypeFullName = _data["ResponseTypeFullName"];
      this.RequestType = _data["RequestType"];
      this.ResponseType = _data["ResponseType"];
      if (Array.isArray(_data["Authorization"])) {
        this.Authorization = [] as any;
        for (let item of _data["Authorization"])
          this.Authorization!.push(item);
      }
    }
  }

  static fromJS(data: any): PublishedRoute {
    data = typeof data === 'object' ? data : {};
    let result = new PublishedRoute();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["Name"] = this.Name;
    data["Method"] = this.Method;
    data["Path"] = this.Path;
    data["PathTemplate"] = this.PathTemplate;
    data["Invocation"] = this.Invocation;
    data["Controller"] = this.Controller;
    data["RequestTypeFullName"] = this.RequestTypeFullName;
    data["ResponseTypeFullName"] = this.ResponseTypeFullName;
    data["RequestType"] = this.RequestType;
    data["ResponseType"] = this.ResponseType;
    if (Array.isArray(this.Authorization)) {
      data["Authorization"] = [];
      for (let item of this.Authorization)
        data["Authorization"].push(item);
    }
    return data;
  }
}

/** Published Routes used by dashboard */
export interface IPublishedRoute {
  /** Route Name */
  Name?: string | undefined;
  /** Method GET, POST, etc */
  Method?: string | undefined;
  /** PATH of the route */
  Path?: string | undefined;
  /** Full Path Template with {} */
  PathTemplate?: string | undefined;
  Invocation?: string | undefined;
  /** Controller of the method */
  Controller?: string | undefined;
  /** Request Type Full Name if any */
  RequestTypeFullName?: string | undefined;
  /** Response Type Full Name if any */
  ResponseTypeFullName?: string | undefined;
  /** Request Type Name if any */
  RequestType?: string | undefined;
  /** Response Type Name if any */
  ResponseType?: string | undefined;
  /** Secured string -&gt; [ADMIN, API_USER] */
  Authorization?: string[] | undefined;
}

export class CacheEntry implements ICacheEntry {
  CachedItemKey?: string | undefined;
  /** The Cached Item Type */
  CachedItemType?: string | undefined;
  /** The Cached Item Size */
  CachedItemSize?: number;
  /** DateTime of the cached result
   it has value only if IsCachedResponse = true -&gt; is a Cached Response */
  CachedDateTimeUtc?: string;
  /** ExpirationTimeSpan of the cached Response
   it has value only if IsCachedResponse = true -&gt; is a Cached Response
   Format d.hh:mm:ss */
  ExpirationTimeSpan?: string;
  /** Absolute Expiration DateTime */
  ExpirationAbsoluteDateTimeUtc?: string;

  constructor(data?: ICacheEntry) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.CachedItemKey = _data["CachedItemKey"];
      this.CachedItemType = _data["CachedItemType"];
      this.CachedItemSize = _data["CachedItemSize"];
      this.CachedDateTimeUtc = _data["CachedDateTimeUtc"];
      this.ExpirationTimeSpan = _data["ExpirationTimeSpan"];
      this.ExpirationAbsoluteDateTimeUtc = _data["ExpirationAbsoluteDateTimeUtc"];
    }
  }

  static fromJS(data: any): CacheEntry {
    data = typeof data === 'object' ? data : {};
    let result = new CacheEntry();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["CachedItemKey"] = this.CachedItemKey;
    data["CachedItemType"] = this.CachedItemType;
    data["CachedItemSize"] = this.CachedItemSize;
    data["CachedDateTimeUtc"] = this.CachedDateTimeUtc;
    data["ExpirationTimeSpan"] = this.ExpirationTimeSpan;
    data["ExpirationAbsoluteDateTimeUtc"] = this.ExpirationAbsoluteDateTimeUtc;
    return data;
  }
}

export interface ICacheEntry {
  CachedItemKey?: string | undefined;
  /** The Cached Item Type */
  CachedItemType?: string | undefined;
  /** The Cached Item Size */
  CachedItemSize?: number;
  /** DateTime of the cached result
   it has value only if IsCachedResponse = true -&gt; is a Cached Response */
  CachedDateTimeUtc?: string;
  /** ExpirationTimeSpan of the cached Response
   it has value only if IsCachedResponse = true -&gt; is a Cached Response
   Format d.hh:mm:ss */
  ExpirationTimeSpan?: string;
  /** Absolute Expiration DateTime */
  ExpirationAbsoluteDateTimeUtc?: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
  if (result !== null && result !== undefined)
    throw result;
  else
    throw new ApiException(message, status, response, headers, null);
}
